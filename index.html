<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>My Coinbase Bot</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #000;
        --panel: #0b0c0f;
        --panel-border: rgba(255, 255, 255, 0.03);
        --text: #fff;
        --muted: rgba(255, 255, 255, 0.4);
        --accent: #fff;
        --row-hover: rgba(255, 255, 255, 0.04);
        --badge-buy: rgba(55, 208, 128, 0.12);
        --badge-buy-text: #37d080;
        --badge-sell: rgba(255, 92, 92, 0.12);
        --badge-sell-text: #ff5c5c;
        --badge-hold: rgba(255, 255, 255, 0.04);
        --badge-hold-text: rgba(255, 255, 255, 0.6);
        --scroll: rgba(255, 255, 255, 0.1);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 2.5rem 1rem 4rem;
      }
      .app {
        width: min(1180px, 100%);
        background: var(--panel);
        border: 1px solid var(--panel-border);
        border-radius: 1.5rem;
        padding: 1.5rem 1.25rem 1.25rem;
        box-shadow: 0 18px 70px rgba(0, 0, 0, 0.35);
      }
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.4rem;
      }
      h1 {
        margin: 0;
        font-size: 1.7rem;
        letter-spacing: -0.03em;
      }
      .status {
        display: flex;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.7rem;
        color: var(--muted);
      }
      .dot {
        width: 8px;
        height: 8px;
        background: #37d080;
        border-radius: 999px;
      }
      .layout {
        display: grid;
        grid-template-columns: 270px 1fr;
        gap: 1.1rem;
      }
      .left {
        background: rgba(255, 255, 255, 0.01);
        border-radius: 1.05rem;
        border: 1px solid rgba(255, 255, 255, 0.01);
        display: flex;
        flex-direction: column;
        height: 420px;
        overflow: hidden;
      }
      .search-wrap {
        padding: 0.4rem 0.5rem 0.45rem;
      }
      .search {
        width: 100%;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.01);
        border-radius: 999px;
        padding: 0.35rem 0.6rem 0.4rem;
        color: #fff;
        font-size: 0.7rem;
      }
      .list {
        flex: 1;
        overflow-y: auto;
      }
      .list::-webkit-scrollbar {
        width: 5px;
      }
      .list::-webkit-scrollbar-thumb {
        background: var(--scroll);
        border-radius: 999px;
      }
      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.4rem;
        padding: 0.45rem 0.55rem;
        cursor: pointer;
        border-radius: 0.75rem;
      }
      .row:hover,
      .row.active {
        background: var(--row-hover);
      }
      .row-left {
        display: flex;
        flex-direction: column;
        gap: 0.1rem;
      }
      .symbol {
        font-size: 0.72rem;
        font-weight: 500;
      }
      .price {
        font-size: 0.62rem;
        color: var(--muted);
      }
      .badge {
        font-size: 0.55rem;
        border-radius: 999px;
        padding: 0.15rem 0.45rem 0.2rem;
        font-weight: 600;
        white-space: nowrap;
      }
      .badge.buy {
        background: var(--badge-buy);
        color: var(--badge-buy-text);
      }
      .badge.sell {
        background: var(--badge-sell);
        color: var(--badge-sell-text);
      }
      .badge.hold {
        background: var(--badge-hold);
        color: var(--badge-hold-text);
      }
      .right {
        background: rgba(255, 255, 255, 0.01);
        border-radius: 1.05rem;
        border: 1px solid rgba(255, 255, 255, 0.01);
        height: 420px;
        display: flex;
        flex-direction: column;
      }
      .coin-top {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.7rem 0.75rem 0;
      }
      .coin-meta {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }
      .coin-title {
        font-weight: 600;
      }
      .coin-value {
        font-size: 0.85rem;
      }
      .tabs {
        display: flex;
        gap: 0.4rem;
      }
      .tab {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.01);
        border-radius: 999px;
        font-size: 0.6rem;
        padding: 0.25rem 0.55rem 0.33rem;
        color: var(--muted);
        cursor: pointer;
      }
      .tab.active {
        background: rgba(255, 255, 255, 0.11);
        color: #fff;
      }
      .chart-box {
        flex: 1;
        padding: 0.6rem 0.75rem 0.75rem;
        position: relative;
      }
      #chart {
        width: 100%;
        height: 100%;
        border-radius: 0.6rem;
        background: rgba(0, 0, 0, 0);
        display: block;
      }
      .chart-foot {
        padding: 0 0.75rem 0.6rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.6rem;
        color: var(--muted);
      }
      .signal-pill {
        border-radius: 999px;
        padding: 0.25rem 0.6rem;
        background: rgba(255, 255, 255, 0.02);
      }
      .refresh {
        margin-top: 1.05rem;
        background: #fff;
        color: #000;
        border-radius: 999px;
        height: 33px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        font-weight: 600;
        cursor: pointer;
      }
      @media (max-width: 920px) {
        .layout {
          grid-template-columns: 1fr;
        }
        .left {
          height: 220px;
        }
        .right {
          height: 380px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="header">
        <div>
          <h1>My Coinbase Bot</h1>
          <div class="status">
            <span class="dot"></span>
            <span id="conn">connected to bot</span>
          </div>
        </div>
        <!-- settings removed = always dark -->
      </div>

      <div class="layout">
        <div class="left">
          <div class="search-wrap">
            <input id="search" class="search" placeholder="search coin..." />
          </div>
          <div id="list" class="list"></div>
        </div>
        <div class="right">
          <div class="coin-top">
            <div class="coin-meta">
              <div id="coinTitle" class="coin-title">Select a coin</div>
              <div id="coinValue" class="coin-value">$—</div>
            </div>
            <div class="tabs" id="rangeTabs">
              <div class="tab active" data-range="24h">24h</div>
              <div class="tab" data-range="1m">1M</div>
              <div class="tab" data-range="6m">6M</div>
              <div class="tab" data-range="1y">1Y</div>
            </div>
            <div class="tabs" id="chartTabs">
              <div class="tab active" data-chart="line">Line</div>
              <div class="tab" data-chart="candles">Candles</div>
            </div>
          </div>
          <div class="chart-box">
            <canvas id="chart"></canvas>
          </div>
          <div class="chart-foot">
            <span id="updated">updated —</span>
            <span id="signal" class="signal-pill">signal: HOLD · 50%</span>
          </div>
        </div>
      </div>

      <div id="refresh" class="refresh">Refresh</div>
    </div>

    <script>
      // ---------------- CONFIG / CONSTANTS ----------------
      const PRICE_ENDPOINT = "/prices";
      const HISTORY_ENDPOINT = "/history";

      // signal thresholds (less jumpy)
      const MIN_MOVE_FOR_SIGNAL = 0.015; // 1.5% ignore micro
      const BUY_DIP_THRESHOLD = -0.035; // -3.5% dip
      const SELL_PUMP_THRESHOLD = 0.025; // +2.5% pump
      const SIGNAL_COOLDOWN_MS = 180_000; // 3 minutes
      const UI_UPDATE_THRESHOLD = 0.002; // 0.2%

      // ---------------- STATE ----------------
      let coins = [];
      let filtered = [];
      let selectedSymbol = null;
      let selectedRange = "24h";
      let selectedChart = "line";
      const signalState = {}; // {SYM: {signal,pct,lastPrice,lastChange}}

      const listEl = document.getElementById("list");
      const coinTitleEl = document.getElementById("coinTitle");
      const coinValueEl = document.getElementById("coinValue");
      const updatedEl = document.getElementById("updated");
      const signalEl = document.getElementById("signal");
      const searchEl = document.getElementById("search");
      const canvas = document.getElementById("chart");
      const ctx = canvas.getContext("2d");

      function sizeCanvas() {
        const box = canvas.parentElement.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = box.width * dpr;
        canvas.height = (box.height - 8) * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      window.addEventListener("resize", sizeCanvas);
      window.addEventListener("load", sizeCanvas);

      // ---------------- SIGNAL LOGIC ----------------
      function getSignalFor(coin) {
        const now = Date.now();
        const sym = coin.symbol;
        const price = coin.price;

        if (!signalState[sym]) {
          signalState[sym] = {
            signal: "HOLD",
            pct: 50,
            lastPrice: price,
            lastChange: now,
          };
          return signalState[sym];
        }

        const prev = signalState[sym];
        const pctMove = (price - prev.lastPrice) / prev.lastPrice;

        // cooldown: don't flip every poll
        if (now - prev.lastChange < SIGNAL_COOLDOWN_MS) {
          // still update lastPrice slowly
          if (Math.abs(pctMove) > 0.0005) {
            prev.lastPrice = price;
          }
          return prev;
        }

        // ignore tiny moves < 1.5%
        if (Math.abs(pctMove) < MIN_MOVE_FOR_SIGNAL) {
          prev.lastPrice = price;
          return prev;
        }

        let nextSig = "HOLD";
        let nextPct = 50;
        if (pctMove <= BUY_DIP_THRESHOLD) {
          nextSig = "BUY";
          nextPct = 82;
        } else if (pctMove >= SELL_PUMP_THRESHOLD) {
          nextSig = "SELL";
          nextPct = 80;
        } else {
          nextSig = "HOLD";
          nextPct = 50;
        }

        signalState[sym] = {
          signal: nextSig,
          pct: nextPct,
          lastPrice: price,
          lastChange: now,
        };
        return signalState[sym];
      }

      // ---------------- LIST RENDER ----------------
      function renderList() {
        listEl.innerHTML = "";
        // sort: BUY first, then HOLD, then SELL
        const sorted = [...filtered].sort((a, b) => {
          const sa = getSignalFor(a);
          const sb = getSignalFor(b);
          const ord = s =>
            s.signal === "BUY" ? 0 : s.signal === "HOLD" ? 1 : 2;
          const oa = ord(sa);
          const ob = ord(sb);
          if (oa !== ob) return oa - ob;
          // tie -> higher price
          return (b.price || 0) - (a.price || 0);
        });
        sorted.forEach(c => {
          const row = document.createElement("div");
          row.className =
            "row" + (c.symbol === selectedSymbol ? " active" : "");
          row.onclick = () => {
            selectedSymbol = c.symbol;
            renderList();
            renderRight(c);
          };

          const left = document.createElement("div");
          left.className = "row-left";
          const s = document.createElement("div");
          s.className = "symbol";
          s.textContent = c.symbol;
          const p = document.createElement("div");
          p.className = "price";
          p.textContent = "$" + (c.price || 0).toLocaleString();
          left.appendChild(s);
          left.appendChild(p);

          const sig = getSignalFor(c);
          const badge = document.createElement("div");
          badge.className =
            "badge " +
            (sig.signal === "BUY"
              ? "buy"
              : sig.signal === "SELL"
              ? "sell"
              : "hold");
          badge.textContent = sig.signal + " · " + sig.pct + "%";

          row.appendChild(left);
          row.appendChild(badge);

          listEl.appendChild(row);
        });
      }

      // ---------------- CHARTS ----------------
      function drawLine(points) {
        sizeCanvas();
        const w = canvas.width / (window.devicePixelRatio || 1);
        const h = canvas.height / (window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, w, h);
        if (!points || !points.length) return;
        const prices = points.map(p => p.price);
        const min = Math.min(...prices);
        const max = Math.max(...prices);
        const padX = 18;
        const padY = 12;
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#37d080";
        points.forEach((p, i) => {
          const x =
            padX + (i / Math.max(1, points.length - 1)) * (w - padX * 2);
          const y =
            padY +
            ((max - p.price) / Math.max(0.0001, max - min)) * (h - padY * 2);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }

      function drawCandles(points) {
        sizeCanvas();
        const w = canvas.width / (window.devicePixelRatio || 1);
        const h = canvas.height / (window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, w, h);
        if (!points || !points.length) return;
        const prices = points.flatMap(p => [p.open, p.close, p.high, p.low]);
        const min = Math.min(...prices);
        const max = Math.max(...prices);
        const padX = 16;
        const padY = 10;
        const usableW = w - padX * 2;
        const candleW = Math.min(12, usableW / points.length - 2);

        points.forEach((p, i) => {
          const baseX = padX + i * (usableW / points.length) + candleW / 2;
          const yHigh =
            padY + ((max - p.high) / (max - min)) * (h - padY * 2);
          const yLow = padY + ((max - p.low) / (max - min)) * (h - padY * 2);
          const yOpen =
            padY + ((max - p.open) / (max - min)) * (h - padY * 2);
          const yClose =
            padY + ((max - p.close) / (max - min)) * (h - padY * 2);
          const up = p.close >= p.open;
          ctx.strokeStyle = up ? "#37d080" : "#ff5c5c";
          ctx.beginPath();
          ctx.moveTo(baseX, yHigh);
          ctx.lineTo(baseX, yLow);
          ctx.stroke();

          ctx.fillStyle = up ? "#37d080" : "#ff5c5c";
          const top = Math.min(yOpen, yClose);
          const height = Math.max(3, Math.abs(yOpen - yClose));
          ctx.fillRect(baseX - candleW / 2, top, candleW, height);
        });
      }

      function buildMockSeries(basePrice) {
        // always return something so chart never blank
        return Array.from({ length: 48 }, (_, i) => ({
          price: basePrice * (1 + Math.sin(i / 6) * 0.04),
        }));
      }

      async function loadHistory(symbol, range, fallbackPrice) {
        try {
          const res = await fetch(
            `${HISTORY_ENDPOINT}?symbol=${encodeURIComponent(
              symbol
            )}&range=${encodeURIComponent(range)}`
          );
          if (!res.ok) throw new Error("bad history");
          const data = await res.json();
          // accept array or object
          if (Array.isArray(data) && data.length) {
            return data.map(d => ({
              price: Number(d.price || d.value || fallbackPrice),
            }));
          }
        } catch (e) {
          // ignore
        }
        return buildMockSeries(fallbackPrice);
      }

      // ---------------- RIGHT PANEL ----------------
      async function renderRight(coin) {
        if (!coin) return;
        coinTitleEl.textContent = coin.symbol;
        coinValueEl.textContent = "$" + (coin.price || 0).toLocaleString();
        updatedEl.textContent = "updated " + new Date().toLocaleTimeString();

        const points = await loadHistory(
          coin.symbol,
          selectedRange,
          coin.price || 100
        );

        if (selectedChart === "line") {
          drawLine(points);
        } else {
          // fake OHLC from line points
          const candles = points.map(p => {
            const b = p.price;
            return {
              open: b * (1 + (Math.random() - 0.5) * 0.005),
              close: b * (1 + (Math.random() - 0.5) * 0.005),
              high: b * (1 + Math.random() * 0.01),
              low: b * (1 - Math.random() * 0.01),
            };
          });
          drawCandles(candles);
        }

        const sig = getSignalFor(coin);
        signalEl.textContent = `signal: ${sig.signal} · ${sig.pct}%`;
        signalEl.style.background =
          sig.signal === "BUY"
            ? "rgba(55, 208, 128, 0.12)"
            : sig.signal === "SELL"
            ? "rgba(255, 92, 92, 0.12)"
            : "rgba(255,255,255,0.03)";
        signalEl.style.color =
          sig.signal === "BUY"
            ? "#37d080"
            : sig.signal === "SELL"
            ? "#ff5c5c"
            : "rgba(255,255,255,0.6)";
      }

      // ---------------- LOAD PRICES ----------------
      async function loadPrices(force = false) {
        try {
          const res = await fetch(PRICE_ENDPOINT);
          if (!res.ok) throw new Error("prices failed");
          const data = await res.json();
          const nextCoins = Object.entries(data).map(([symbol, price]) => ({
            symbol,
            price: Number(price),
          }));

          let needRender = force || coins.length === 0;
          if (!needRender) {
            for (const nc of nextCoins) {
              const old = coins.find(c => c.symbol === nc.symbol);
              if (!old) {
                needRender = true;
                break;
              }
              const diff = Math.abs(nc.price - old.price) / old.price;
              if (diff > UI_UPDATE_THRESHOLD) {
                needRender = true;
                break;
              }
            }
          }

          coins = nextCoins;
          filtered = coins;

          if (!selectedSymbol && coins.length) {
            selectedSymbol = coins[0].symbol;
          }

          if (needRender) {
            renderList();
            const cur = coins.find(c => c.symbol === selectedSymbol);
            if (cur) renderRight(cur);
          }
          document.getElementById("conn").textContent = "connected to bot";
        } catch (e) {
          document.getElementById("conn").textContent =
            "failed to reach bot";
        }
      }

      // ---------------- EVENTS ----------------
      searchEl.addEventListener("input", e => {
        const q = e.target.value.toLowerCase();
        filtered = coins.filter(c => c.symbol.toLowerCase().includes(q));
        renderList();
      });

      document.querySelectorAll("#rangeTabs .tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document
            .querySelectorAll("#rangeTabs .tab")
            .forEach(t => t.classList.remove("active"));
          tab.classList.add("active");
          selectedRange = tab.dataset.range;
          const coin = coins.find(c => c.symbol === selectedSymbol);
          if (coin) renderRight(coin);
        });
      });

      document.querySelectorAll("#chartTabs .tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document
            .querySelectorAll("#chartTabs .tab")
            .forEach(t => t.classList.remove("active"));
          tab.classList.add("active");
          selectedChart = tab.dataset.chart;
          const coin = coins.find(c => c.symbol === selectedSymbol);
          if (coin) renderRight(coin);
        });
      });

      document.getElementById("refresh").addEventListener("click", () =>
        loadPrices(true)
      );

      // ---------------- INIT ----------------
      loadPrices(true);
      // poll but we only re-render if change > 0.2%
      setInterval(() => loadPrices(false), 10_000);
    </script>
  </body>
</html>
